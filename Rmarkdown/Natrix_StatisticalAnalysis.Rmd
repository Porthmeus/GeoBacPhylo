---
title: "Statistical Analysis"
author: "Jan Taubenheim"
date: "7/30/2020"
output: html_document
---
```{r setup, message=FALSE}

knitr::opts_chunk$set(message = FALSE, warning = FALSE)

require(data.table)
require(DESeq2)
if(!("qiime2R" %in% installed.packages()[,"Package"])){
    devtools::install_github("jbisanz/qiime2R")
}
require(qiime2R)
require(ggplot2)
require(vegan)
require(phyloseq)
require(umap)
require(MASS)
require(cowplot)
require(geosphere)
require(lme4)
require(nlme)
require(car)
require(jtools)

```

```{r debuggin, eval = FALSE,include=FALSE}
# set this part to include =FALSE, before running snakemake, as it is meant for
# debugging and testing. I will create an S4 object matching the one snakemake
# parses, so that I can use the code as is downstream

setClass("snakemake", representation(input = "list", output = "list"))
snakemake <- new("snakemake", 
                    input = list(
                        AbFilt_FT = "../data/dada2_AbFilt_FT.csv",
                        AbFilt_Tax = "../data/dada2_AbFilt_Tax.csv",
                        AbFilt_meta = "../data/dada2_AbFilt_meta.csv",
                        AbFilt_fasta_tree = "../data/dada2_AbFilt_fasta_tree.qza",
                        MetaLakes = "../MetaDataLakes.csv"
                    ),
                    output = list(
                        html = "Rmarkdown/Natrix_StatisticalAnalysis.html"
                    )
                )

```


# Statistical analysis

The main questions are:

    * do microbiomes of Hydra from different locations differ
    * do microbiomes differ between species
    * do microbiomes differ between different sexual states 

The two common ways to test that is using an Anosim (a non parametric test on beta diversity) and an Adonis test (comparable to MANOVA on beta diversity). Common practice is to resample the libraries to the minimum number of reads per sample with the problem of loosing most of the data.
However, the recommendation for statistical analysis based on the phyloseq authors are to normalize the reads with the DESeq2 package (which is also used to determine differential ASV between conditions) and the implementation of the variance stabilization transformation (vst). This requires, that at least one ASV is common to all samples, which is not the case for the diverse sample I got. To circumvent this problem, I will add a single read to every ASV in every sample. Another common and quite well working transformation is dividing by the library size. I will use the raw, the vst and the fraction to do the statistics.

```{r loadData, message = FALSE}

otu <- read.csv(snakemake@input[["AbFilt_FT"]], row.names = 1) #"../data/dada2_AbFilt_FT.csv"
tax <- read.csv(snakemake@input[["AbFilt_Tax"]], row.names=1)#"../data/dada2_AbFilt_Tax.csv"
meta <- read.csv(snakemake@input[["AbFilt_meta"]], row.names=1)#"../data/dada2_AbFilt_meta.csv"
tree <- read_qza(snakemake@input[["AbFilt_fasta_tree"]])$data #"../data/dada2_AbFilt_fasta_tree.qza"

#otu <- read.csv("../data/dada2_AbFilt_FT.csv", row.names = 1)
#tax <- read.csv("../data/dada2_AbFilt_Tax.csv", row.names =1)
#meta <- read.csv("../data/dada2_AbFilt_meta.csv", row.names=1)
#tree <- read_qza("../data/dada2_AbFilt_fasta_tree.qza")$data

# remap the reproductive mode to the SEX, ASEX and NR
map_vect <- c("SEX","NR","SEX","ASEX","SEX","SEX","SEX","SEX")
names(map_vect) <- unique(meta$ReproductiveMode)
meta[["ReproductiveModeSimple"]] <- map_vect[meta[["ReproductiveMode"]]]


# artificially add a single count to all ESVs
otu2 <- otu+1

phy <- phyloseq(otu_table(otu, taxa_are_rows = TRUE),
                tax_table(as.matrix(tax)),
                sample_data(meta),
                phy_tree(tree))

otu_vst <- varianceStabilizingTransformation(as.matrix(otu2), fitType = "local")

# shift the vst correction to positive values
if(min(otu_vst) <0){
    otu_vst <- otu_vst + min(otu_vst)*-1
}

# create phyloseq objects
phy_vst <- phyloseq(otu_table(otu_vst,
                              taxa_are_rows = TRUE),
                    tax_table(as.matrix(tax)),
                    sample_data(meta),
                    phy_tree(tree))
phy_frac <- phyloseq(otu_table(otu/colSums(otu), taxa_are_rows = TRUE),
                tax_table(as.matrix(tax)),
                sample_data(meta),
                phy_tree(tree))

trnses <- list(raw = phy, vst = phy_vst, frac = phy_frac)

```

So lets look on the raw data here and whether we already see a separation there (on euclidean distance).

```{r ordinateRaw, fig.width = 12, fig.height=12, message=FALSE}

countPlots <- list()
plotDF <- data.frame()
for(n in names(trnses)){
    # calculate ordination
    pca <- prcomp(t(otu_table(trnses[[n]])))
    nmds <- isoMDS(dist(t(otu_table(trnses[[n]]))))
    ump <- umap(t(otu_table(trnses[[n]])))
    
    # create plots
    nPCA <- paste(n,"PCA",sep = "_")
    countPlots[[nPCA]] <- ggplot(as.data.frame(pca$x),
                                 aes(x=PC1, y=PC2, col = meta$PopID)) +
        geom_point() +
        ggtitle(nPCA) +
        theme(legend.position = "none")
    nNMDS <- paste(n,"NMDS", sep = "_")
    countPlots[[nNMDS]] <- ggplot(as.data.frame(nmds$points),
                                  aes(x=V1, y=V2, col = meta$PopID)) +
        geom_point() +
        ggtitle(nNMDS) +
        theme(legend.position = "none")
    nUMAP <- paste(n,"UMAP",sep ="_")
    countPlots[[nUMAP]] <- ggplot(as.data.frame(ump$layout),
                                  aes(x=V1, y=V2, col = meta$PopID))+
        geom_point() +
        ggtitle(nUMAP)
    
    
    # combine the plotting data in one data.frame
    plotDF <- rbind(plotDF,
                        cbind(V1 = pca$x[,1], V2 =pca$x[,2], ordination = "PCA", data = n, sample = rownames(pca$x)),
                        cbind(as.data.frame(nmds$points), ordination = "NMDS", data = n, sample = rownames(nmds$points)),
                        cbind(as.data.frame(ump$layout), ordination = "UMAP", data =n, sample = rownames(ump$layout)),
                    deparse.level = 2
    )
}

# plot the different normalizations next to each other
plotDF<- merge(plotDF, meta, by.x="sample", by.y=0)
plotDF[,"V1"] <- as.numeric(plotDF[,"V1"])
plotDF[,"V2"] <- as.numeric(plotDF[,"V2"])

normPlots <- list()
for(n in names(trnses)){
    normPlots[[n]] <- ggplot(plotDF[plotDF[["data"]] == n,], aes(x = V1, y=V2, col =PopID)) +
            facet_wrap(.~ordination, scales = "free") +
            geom_point()+
            ggtitle(n) +
            theme(legend.position = "None")
}
cowplot::plot_grid(plotlist = normPlots, ncol =1)

```


To calculate differences between treatments, one needs to calculate $\beta$-diversity between samples. There are several distance measures, which can be calculated, the most common though are: Bray-Curtis, Jaccard, Unifrac and Weighted Unifrac. I will calculate all. To evaluate which might be the best to do statistics on, and which input data to use, I will plot ordination of the distance data. This is done by NMDS, PCoA, and UMAP.

```{r Distances, echo = FALSE, message=FALSE, warning =FALSE, fig.width=16, fig.height=20}

distMs <- c("euclidean", "bray","jaccard","unifrac","wunifrac")
mtrxs <- list()
for(n in names(trnses)){
    for(meas in distMs){
        nn <- paste(meas,n, sep = "_")
        print(nn)
        mtrxs[[nn]] <- phyloseq::distance(trnses[[n]], method = meas)
    }
}

ordis <- list()
plots <- list()
for(n in names(trnses)){
    for(meas in distMs){
        for(ordinat in c("NMDS","PCoA","UMAP")){
        nn <- paste(meas,n,ordinat, sep = "_")
        print(nn)
        if(ordinat == "NMDS"){
            ordi <- ordinate(trnses[[n]], method = ordinat, distance = mtrxs[[paste(meas,n, sep ="_")]])
            plots[[nn]] <- ggplot(as.data.frame(ordi$points), aes(x=MDS1, y=MDS2, color = meta$PopID)) +
                ggtitle(nn) +
                geom_point()
        } else if ( ordinat =="PCoA"){
            
            ordi<- tryCatch({
            ordinate(trnses[[n]], method = ordinat, distance = mtrxs[[paste(meas,n, sep ="_")]])
            },
            error = function(cond){
                message(cond)
                message("\nreturn empty object to ordis and empty plot to plots")
                message(paste("Error occured in",n,ordinat, meas)) 
                return(NA)
            })
            if(is.na(ordi)){
                plots[[nn]] <- ggplot()+ggtitle(nn)
            } else {
                plots[[nn]] <- ggplot(as.data.frame(ordi$vectors), aes(x = Axis.1, y=Axis.2, color = meta$PopID)) + 
                    ggtitle(nn) +
                    geom_point()
            }
            
        } else if (ordinat == "UMAP"){
            ordi <- umap(as.matrix(mtrxs[[paste(meas, n, sep ="_")]]), input="dist")
            plots[[nn]] <- ggplot(as.data.frame(ordi$layout), aes(x=V1,y=V2, color = meta$PopID))+
                ggtitle(nn) +
                geom_point()
        }
        ordis[[nn]] <- ordi
        }
    }
}

plots <- lapply(plots, function(x){x+theme(legend.position="None")})
for(n in names(trnses)){
    sel <- grep(paste0("_",n,"_"), names(plots))
    p <- cowplot::plot_grid(plotlist = plots[sel], ncol = 3)
    print(p)
}


```

From the plots it looks like the vst normalization in the UMAP clustering for euclidean distances gives best results for separation of Hydra from different locations directly. If one settles on one of the mostly used algorithms it looks like vst-bray and vst-jaccard give reliable results (at least UMAP is able to cluster them quite well). The data has many dimensions, which makes it difficult for NMDS an PCoA to reveal common patterns in the samples. Surprisingly the unifrac and wunifrac distances look rather scattered and give relatively bad clustering, which might imply that the inferred fast-tree ML-tree is no really representing the phylogenetic distance of the bacterial species, or that that the phylogenetic distance is not a good descriptor for the samples.

Lets see, whether the ordination is also representative for Species and Reproductive Mode differences.

```{r ordination2, fig.width=16, fig.height=20}

sel <- paste(c("euclidean","bray","jaccard"),"vst", sep ="_")
plots2 <- list()
for(nm in sel){
    ordi <- umap(as.matrix(mtrxs[[nm]]), input="dist")
    plots2[[paste(nm,"RepMod",sep="_")]] <- ggplot(as.data.frame(ordi$layout), aes(x=V1,y=V2, color = meta$ReproductiveModeSimple))+
        ggtitle(nm) +
        labs(color = "RepMode")+
        geom_point()
    plots2[[paste(nm,"Species",sep="_")]] <- ggplot(as.data.frame(ordi$layout), aes(x=V1,y=V2, color = meta$Species))+
        ggtitle(nm) +
        labs(color = "Species")+
        geom_point()
    plots2[[paste(nm,"PopID",sep="_")]] <- ggplot(as.data.frame(ordi$layout), aes(x=V1,y=V2, color = meta$PopID))+
        ggtitle(nm) +
        labs(color = "PopID")+
        geom_point()
}
pp_UMAP <- cowplot::plot_grid(plotlist=plots2, ncol = 3)
pp_UMAP


```


Knowing these things, I will calculate an adonis on the euclidean, bray and jaccard distances for the vst normalized data and check for significant differences in sampling location (= Population ID [PopID]), reproductive mode (ReproductiveMode) and Species (Species).

```{r statistics}


sel <- paste(c("euclidean","bray","jaccard"),"vst", sep ="_")
stats <- list()
for(n in sel){
    stats[[n]] <- adonis(formula = mtrxs[[n]] ~meta$Species+meta$ReproductiveModeSimple+ meta$PopID, perm = 200)
}

print("Adonis testing for PopID")
print(stats[sel])

stats0.5 <- list()
for(n in sel){
    stats0.5[[n]] <- adonis(formula = mtrxs[[n]] ~meta$PopID, perm = 200)
}
print("Adonis testing for PopID ONLY")
print(stats0.5[sel])


stats2 <- list()
for(n in sel){
    stats2[[n]] <- adonis(formula = mtrxs[[n]] ~  meta$Species, strata= meta$PopID, perm =200)
}

print("Adonis testing for Species and Reproductive Mode")
print(stats2)

# select only oligactis for species test in adonis

sel2 <- rownames(meta[meta$Species == "OLI",])

stats3 <- list()
for(n in sel){
    stats3[[n]] <- adonis(formula = as.matrix(mtrxs[[n]])[sel2,sel2] ~  meta[sel2,"ReproductiveModeSimple"], strata= meta[sel2,"PopID"], perm =200)
}
print("Adonis testing for Reproductive Mode")
print(stats3)

```

To finally answer the main question from the beginning: 
1.) There is a consistent and rather strong signature in the data which is indicative for the sampling location, hence bacterial communities in Hydra differ if they live in different locations. 
2.) There is a consistent difference in the bacterial communities from different Hydra species (this is what was expected).
3.) There is a less strong, but detectable change in the microbial community if the animals have different reproductive modes. This is only detectable if the model design is stratified by the sampling location of the 16S data. However, it indicates, that change in the reproductive mode is associated with the differences in the microbiota. 


We obtained new meta data for the lakes where the animals were sampled and Sebastian suggested to test for differences in the microbiota in dependence of the water body. Does it make a difference if Hydra lives in a lake or a flowing (river) water body? Further we obtained the geocoordinates of the sampling sites. I will use the distance between geolocation and $\beta$-diversity to correlate these two frameworks.

```{r LakeMetaData, fig.height = 12, fig.width = 8}

metaLakes <- read.csv(snakemake@input[["MetaLakes"]])

# join the meta data
meta2 <- merge(meta, metaLakes, by.x = "PopID", by.y = "SiteID", all.x=TRUE)


stats3 <- list()
for(n in sel){
    stats3[[n]] <- adonis(formula = mtrxs[[n]] ~ meta2$waterbody, perm =500)
}
stats3
# The waterbody is a factor which changes the microbiota!

stats4 <- list()
for(n in sel){
    stats4[[n]] <- adonis(formula = mtrxs[[n]] ~ factor(meta2$NutrientLoad), perm =500)
}
stats4

# calculate the geographic distance between sampling points
geoDist <- distm(metaLakes[,c("lon","lat")])
colnames(geoDist) <- metaLakes[["SiteID"]]
rownames(geoDist) <- metaLakes[["SiteID"]]

# set the upper triangle to NA, so its easily filtered afterwards
geoDist[upper.tri(geoDist, diag=FALSE)] <- NA

# create a data frame which associates distance of microbiome to geographic distance
geoDistLong <- data.table(reshape2::melt(geoDist))
geoDistLong <- geoDistLong[!is.na(value),]

mtrxsLong <- list()
for(mat in sel){
    bacDist <- as.matrix(mtrxs[[mat]])
    bacDist[upper.tri(bacDist, diag=TRUE)] <- NA
    bacDistLong <- data.table(reshape2::melt(bacDist))
    bacDistLong <- bacDistLong[!is.na(value),]
    # add the PopID information to associate it back to the geographic distance
    bacDistLong <- cbind(bacDistLong, 
                          Var1PopID = meta[bacDistLong[,Var1], "PopID"],
                          Var2PopID = meta[bacDistLong[,Var2], "PopID"],
                          GeoDist = -1)
    mtrxsLong[[mat]] <- bacDistLong
}

# merge both tables
for(i in 1:nrow(geoDistLong)){
    for(mat in names(mtrxsLong)){
       sel2 <-  ((mtrxsLong[[mat]][,Var1PopID] %in% geoDistLong[i,Var1] &
                 mtrxsLong[[mat]][,Var2PopID] %in% geoDistLong[i,Var2]) |
                (mtrxsLong[[mat]][,Var2PopID] %in% geoDistLong[i,Var1] &
                 mtrxsLong[[mat]][,Var1PopID] %in% geoDistLong[i,Var2]))
        mtrxsLong[[mat]][sel2, "GeoDist"] <- geoDistLong[i,value]
    }
}


# create simple dotplots
geoDistPlots <- list()
geoDistModels <- list()
for(mat in names(mtrxsLong)){
    nm <- strsplit(mat, split="_")[[1]]
    p <- ggplot(mtrxsLong[[mat]], aes(y=value, x=GeoDist)) +
        geom_point(alpha = 0.1) +
        xlab("Geographic distance") +
        ylab(paste(nm[1], "distance")) +
        ggtitle(paste("Distance based on", nm[2]))
    geoDistPlots[[mat]] <- p
    print(cor.test(method ="pearson", mtrxsLong[[mat]][,value], mtrxsLong[[mat]][,GeoDist]))
    geoDistModels[[mat]] <- lm(data=mtrxsLong[[mat]], value~GeoDist)
}

pp <- cowplot::plot_grid(plotlist = geoDistPlots, ncol = 1)
pp

# create a distance matrix for the distance in geo-location of the same dimensions like the beta-diversity to perform a mantel test
# 1. cast into wide format
geoDist_Samples <- dcast(mtrxsLong[[1]], Var1~Var2, Value.var = "GeoDist")
# 2. format as data.frame, correct rownames, which are missing in data.table
geoDist_Samples_names <- geoDist_Samples[, Var1]
geoDist_Samples <- as.data.frame(geoDist_Samples)
rownames(geoDist_Samples) <- geoDist_Samples_names
geoDist_Samples <- geoDist_Samples[,-1]
# 3. add an additional column and row, because I left out the diagonal by the first conversion from distance to long format
geoDist_Samples <- cbind(geoDist_Samples, added = NA)
colnames(geoDist_Samples)[ncol(geoDist_Samples)] <- geoDist_Samples_names[length(geoDist_Samples_names)]
geoDist_Samples_names <- colnames(geoDist_Samples)
geoDist_Samples <- rbind(added = NA, geoDist_Samples)
rownames(geoDist_Samples)[1] <- geoDist_Samples_names[1]
# 4. reformat into distance object
geoDist_Samples <- as.dist(geoDist_Samples)


# perform a mantel test on the distance matrices
for(mat in names(mtrxsLong)){
    print(mat)
    print(mantel(geoDist_Samples, mtrxs[[mat]]))
}



```

So there is a high statistic significant association of geographic distance and $\beta$-diversity, however, the effect is marginal and probably only significant because of the shear amount of data in the set. Its a nice feature, but I would not make to much a deal out of it.

```{r assocAlphaMeta, fig.height = 8, fig.width = 8}

# The idea of Jacint was to associate the alpha diversity to the 
alphaDiv <- estimate_richness(phy)
alphaNames <- colnames(alphaDiv)
alphaDiv <- merge(alphaDiv, meta, by=0, all.x=TRUE)
# transform the data to fit normality a little better
alphaDiv[["Simpson"]] <- alphaDiv[["Simpson"]]^2
alphaDiv[["Chao1"]] <- log(alphaDiv[["Chao1"]])


alphaPlots <- list()
for(nm in c("Simpson","Shannon","Chao1")){
    for(group in c("PopID", "Species", "ReproductiveModeSimple")){
        id <- paste(nm, group, sep ="_")
        p <- ggplot(alphaDiv, aes_string(x = group, y= nm, fill = group))+
                    geom_boxplot() +
                    ylab(nm) +
                    xlab(group) +
                    theme(legend.position = "None")
        alphaPlots[[id]] <- p
    }
}
pp <- cowplot::plot_grid(plotlist = alphaPlots, rel_widths = rep(c(3,1,1),3))

print(pp)

```

There seems to be major differences in the alpha diversity of the different populations, but also in the different species. Lets fit some linear (mixed) models to the data and see if these differences are significant.

Lets start with the Simpson index:

```{r SimpsonlinearMixedModels}

# lets fit a linear mixed model to the data and check for population
simpFull <- lm(data=alphaDiv, Simpson ~ PopID+Species+ReproductiveModeSimple)
simpPopSpec <- lm(data=alphaDiv, Simpson ~ PopID+Species)
simpPopNull <- lm(data=alphaDiv, Simpson ~ PopID)
simpPopLMM <- lme(data=alphaDiv, Simpson ~ PopID, random = ~1|Species/ReproductiveModeSimple, method = "ML")

anova(simpPopLMM, simpFull)
anova(simpPopLMM, simpPopNull)
# the full model is still better, test the difference to the pop+species model
anova(simpPopNull,simpPopSpec,simpFull)
AIC(simpPopNull,simpPopSpec,simpFull)
BIC(simpPopNull,simpPopSpec,simpFull)
# the linear model with only Population and Species is best fitting the data

# lets check for species differences
simpSpecNull <- lm(data=alphaDiv, Simpson ~ Species)
simpSpecLMM1 <- lme(data=alphaDiv, Simpson ~ Species, random =~1|PopID, method = "ML")
simpSpecLMM2 <- lme(data=alphaDiv, Simpson ~ Species+ReproductiveModeSimple, random =~1|PopID, method = "ML")

anova(simpSpecLMM2, simpSpecLMM1)
anova(simpSpecLMM2, simpFull)
anova(simpSpecLMM2, simpSpecNull)
anova(simpSpecNull, simpPopSpec, simpFull)
AIC(simpSpecNull,simpPopSpec,simpFull)
BIC(simpSpecNull,simpPopSpec,simpFull)
# again the population+Species simple linear model is best fitting the data

simpMod <- simpPopSpec

# ok lets repeat this procedure with the other diversity measures
shanFull <- lm(data=alphaDiv, Shannon ~ PopID+Species+ReproductiveModeSimple)
shanPopSpec <- lm(data=alphaDiv, Shannon ~ PopID+Species)
shanPopNull <- lm(data= alphaDiv, Shannon ~ PopID)
shanSpecNull <- lm(data= alphaDiv, Shannon ~ Species)
shanPopLMM <- lme(data=alphaDiv, Shannon ~ PopID, random = ~1|Species/ReproductiveModeSimple, method = "ML")
shanSpecLMM1 <- lme(data=alphaDiv, Shannon~ Species, random =~1|PopID, method = "ML")
shanSpecLMM2 <- lme(data=alphaDiv, Shannon~ Species+ReproductiveModeSimple, random =~1|PopID, method = "ML")

# find the best population model
anova(shanPopLMM, shanPopNull)
anova(shanPopLMM, shanFull)
anova(shanPopNull, shanPopSpec, shanFull)
AIC(shanPopNull, shanPopSpec, shanFull)
BIC(shanPopNull, shanPopSpec, shanFull)
# this one is a bit tricky, but I would go to the full model here, as log-likelihood and AIC are in concordance here


# species effect
anova(shanSpecLMM1, shanSpecLMM2)
anova(shanSpecLMM2, shanSpecNull)
anova(shanSpecLMM2, shanFull)
anova(shanSpecNull, shanPopSpec, shanFull)
AIC(shanSpecNull, shanPopSpec, shanFull)
BIC(shanSpecNull, shanPopSpec, shanFull)
# again the full model seems to be the best, at least concord in log-likelihood and AIC

shanMod <- shanFull


chaoFull <- lm(data=alphaDiv, Chao1 ~ PopID+Species+ReproductiveModeSimple)
chaoPopNull <- lm(data=alphaDiv, Chao1 ~ PopID)
chaoPopSpec <- lm(data=alphaDiv, Chao1 ~ PopID+Species)
chaoSpecNull<- lm(data=alphaDiv, Chao1 ~ Species)
chaoPopLMM <- lme(data=alphaDiv, Chao1 ~ PopID, random = ~1|Species/ReproductiveModeSimple, method = "ML")
chaoSpecLMM1 <- lme(data=alphaDiv, Chao1 ~ Species, random =~1|PopID, method = "ML")
chaoSpecLMM2 <- lme(data=alphaDiv, Chao1 ~ Species+ReproductiveModeSimple, random =~1|PopID, method = "ML")

# population
anova(chaoPopLMM, chaoPopNull)
anova(chaoPopLMM, chaoFull)
anova(chaoPopNull, chaoPopSpec, chaoFull)
AIC(chaoPopNull, chaoPopSpec, chaoFull)
BIC(chaoPopNull, chaoPopSpec, chaoFull)

# the linear model with population and species is fitting the data best
chaoMod <- chaoPopSpec

# species
anova(chaoSpecLMM1,chaoSpecLMM2 , chaoSpecNull)
anova(chaoSpecLMM1,chaoSpecLMM2 , chaoFull)
anova(chaoSpecNull, chaoPopSpec, chaoFull)
AIC(chaoSpecNull, chaoPopSpec, chaoFull)
BIC(chaoSpecNull, chaoPopSpec, chaoFull)

```

OK after fitting the data to a (rather simple) model lets see if the assumptions hold an plot some diagnostics.

```{r diagnosticsPlotsForModels, warnings=FALSE, message = FALSE}
simp_pp <- plot_grid(~plot(simpMod, which =1),
                     ~plot(simpMod, which =2),
                     ~plot(simpMod,which=4),
                     ~plot(simpMod,which=5))

shan_pp <- plot_grid(~plot(shanMod, which =1),
                     ~plot(shanMod, which =2),
                     ~plot(shanMod,which=4),
                     ~plot(shanMod,which=5))

chao_pp <- plot_grid(~plot(chaoMod, which =1),
                     ~plot(chaoMod, which =2),
                     ~plot(chaoMod,which=4),
                     ~plot(chaoMod,which=5))
simp_pp
shan_pp
chao_pp
```

The models look quite okay, lets look on the coefficients.

```{r modCoefs}

summary(simpMod)
Anova(simpMod)
summary(shanMod)
Anova(shanMod)
summary(chaoMod)
Anova(chaoMod)

```




There is a clear effect of species, and population on alpha diversity in the samples. The populations M78 and M67 have the lowest alpha diversity, while M85 shows highest diversity in the models and plots. In the Shannon index, there is also some statistic difference for the reproductive mode. Sexually propagating animals show the highest alpha diversity. This coincides with the expression of periculin in the egg fleck and might be a consequence of the destroyed homoeostasis of the microbiota in these animals.

Finally we can have a look on the pairwise comparisons.

```{r pairwiseCompAlpha, fig.width = 8, fig.height = 6}

Anova(simpMod)
Anova(shanMod)
Anova(chaoMod)
TukeyHSD(aov(simpMod))
TukeyHSD(aov(shanMod))
TukeyHSD(aov(chaoMod))

# do some nice plots
models <- list("Simpson" = simpMod ,"Shannon" = shanMod,"Chao1" = chaoMod)
effecSizePlots <- list()
for(vrb in c("Species","PopID")){
    for(n in names(models)){
    mod  <- models[[n]]
    prd  <- make_predictions(mod, pred = vrb, data = alphaDiv)
    effecSizePlots[[paste(n,vrb,sep="_")]] <-
        ggplot(prd, aes_string(y = vrb, x=n ,xmin = "ymin", xmax = "ymax")) +
        geom_point() +
        geom_errorbar() +
        ggtitle(paste0("Effect size of ",n))
    }
}

pp <- plot_grid(plotlist=effecSizePlots, ncol = 3, rel_heights =c(0.3,0.7))
print(pp)


```

This last part is has to be taken carefully, as the design is unbalanced and Anova calculates Type II anovas, so only main effects are considered, which is fine as there are no interactions. 

```{r oldAnalysis, include=FALSE}
## get the coefficients of these and add some plots
#print(summary(simpPopLMM)[["call"]])
#print(summary(simpPopLMM)[["tTable"]])
#cowplot::plot_grid(
#                   plot(simpPopLMM,main = "(Simpson index)^2"),
#                   plot(ranef(simpPopLMM))
#                   )
#qqPlot(residuals(simpPopLMM))
#print(summary(shanPopLMM)[["call"]])
#print(summary(shanPopLMM)[["tTable"]])
#cowplot::plot_grid(
#                   plot(shanPopLMM, main = "Shannon index"),
#                   plot(ranef(shanPopLMM))
#                   )
#qqPlot(residuals(shanPopLMM))
#print(summary(chaoPopLMM)[["call"]])
#print(summary(chaoPopLMM)[["tTable"]])
#cowplot::plot_grid(
#                   plot(chaoPopLMM,main = "log(Chao1) index"),
#                   plot(ranef(chaoPopLMM))
#                   )
#qqPlot(residuals(chaoPopLMM))
#
#
#print(summary(simpSpecLMM2)[["call"]])
#print(summary(simpSpecLMM2)[["tTable"]])
#cowplot::plot_grid(
#                   plot(simpSpecLMM2, main = "(Simpson index)^2"),
#                   plot(ranef(simpSpecLMM2))
#                   )
#qqPlot(residuals(simpSpecLMM2))
#print(summary(shanSpecLMM)[["call"]])
#print(summary(shanSpecLMM)[["tTable"]])
#cowplot::plot_grid(
#                   plot(shanSpecLMM, main = "Shannon index"),
#                   plot(ranef(shanSpecLMM))
#                   )
#qqPlot(residuals(shanSpecLMM))
#print(summary(chaoSpecLMM)[["call"]])
#print(summary(chaoSpecLMM)[["tTable"]])
#cowplot::plot_grid(
#                   plot(chaoSpecLMM, main = "log(Chao1) index"),
#                   plot(ranef(chaoSpecLMM))
#                   )
#qqPlot(residuals(chaoSpecLMM))
```
